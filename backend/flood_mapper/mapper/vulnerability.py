import logging
import numpy as np
import pandas as pd
from scipy.ndimage import distance_transform_edt, uniform_filter, binary_erosion
from rasterio.features import rasterize
from tqdm import tqdm
import rasterio
from rasterio.warp import reproject, Resampling

from . import utils

def calculate_vulnerability(clipped_data, config, threat_score=0.0):
    """
    Calculates the composite vulnerability raster by combining multiple
    geospatial factors.

    Args:
        clipped_data (dict): Dictionary of loaded and clipped data.
        config (dict): The project configuration dictionary.
        threat_score (float): The current threat score, used for heuristics.

    Returns:
        np.ndarray: A 2D NumPy array representing the vulnerability score
                    (0-1) for each pixel.
    """
    params = config['combination_params']
    weights = config['vulnerability_weights']
    dem = clipped_data['dem_array'].astype(float)
    profile = clipped_data['dem_profile']
    nodata_mask = (dem == profile['nodata'])
    dem[nodata_mask] = np.nan # Use NaN for calculations

    components = {}

    # 1. Elevation (lower = higher vulnerability)
    logging.info("Calculating elevation component...")
    elevation_inv = np.nanmax(dem) - dem
    components['elevation'] = utils.normalize_array(elevation_inv)
    
    # 2. Slope (flatter = higher vulnerability)
    logging.info("Calculating slope component...")
    px, py = profile['transform'][0], -profile['transform'][4]
    grad_y, grad_x = np.gradient(dem, py, px)
    slope_deg = np.rad2deg(np.arctan(np.sqrt(grad_x**2 + grad_y**2)))
    # Use exponential decay: vulnerability is high for flat slopes and drops off quickly.
    decay_factor = params.get('slope_decay_factor', 0.1)
    slope_vulnerability = np.exp(-decay_factor * slope_deg)
    components['slope'] = utils.normalize_array(slope_vulnerability)

    # 3. LULC Coefficient
    logging.info("Calculating LULC component...")
    lulc = clipped_data['lulc_array'].astype(float)
    lulc[lulc == 0] = np.nan # Set 0 to NaN
    lulc_profile = clipped_data['lulc_profile']
    
    # Resample LULC to match DEM dimensions
    if lulc.shape != dem.shape:
        logging.info(f"Resampling LULC from {lulc.shape} to {dem.shape}")
        resampled_lulc = np.empty(dem.shape, dtype=float)
        reproject(
            source=lulc,
            destination=resampled_lulc,
            src_transform=clipped_data['lulc_profile']['transform'],
            src_crs=clipped_data['lulc_profile']['crs'],
            dst_transform=profile['transform'],
            dst_crs=profile['crs'],
            resampling=Resampling.nearest
        )
        lulc = resampled_lulc

    logging.info(f"LULC nodata value: {lulc_profile['nodata']}")
    logging.info(f"LULC initial unique values: {np.unique(lulc[~np.isnan(lulc)])}")

    # Ensure LULC nodata values are handled.
    lulc_nodata_mask = (lulc == lulc_profile['nodata'])
    lulc[lulc_nodata_mask] = np.nan
    
    # CRITICAL FIX: Apply the master nodata mask from the DEM to the LULC array as well.
    # This ensures that any area that is nodata in the DEM is also nodata in all other components.
    lulc[nodata_mask] = np.nan
    logging.info(f"LULC unique values after setting nodata to NaN: {np.unique(lulc[~np.isnan(lulc)])}")

    lulc_coeffs = config['lulc_coefficients']
    logging.info(f"LULC coefficients: {lulc_coeffs}")
    lulc_vulnerability = np.full(lulc.shape, lulc_coeffs['default'], dtype=float)
    
    # Create a mask for valid (non-NaN) LULC pixels
    valid_mask = ~np.isnan(lulc)
    
    # Convert LULC values to integer for mapping, only for valid pixels
    lulc_int = np.zeros_like(lulc, dtype=int)
    lulc_int[valid_mask] = lulc[valid_mask].astype(int)
    
    # Vectorized mapping: Apply coefficients from config
    for value, coeff in lulc_coeffs.items():
        if value != 'default':
            lulc_vulnerability[(lulc_int == int(value)) & valid_mask] = coeff
            
    components['lulc'] = lulc_vulnerability

    # 4. Distance to Water (closer = higher vulnerability)
    logging.info("Calculating distance to water component...")
    water_geoms = pd.concat([
        clipped_data['rivers'].geometry,
        clipped_data['waterbodies'].geometry
    ]).unary_union

    if not water_geoms.is_empty:
        water_mask = rasterize(
            [(water_geoms, 1)],
            out_shape=dem.shape,
            transform=profile['transform'],
            fill=0,
            dtype='uint8'
        ).astype(bool)
        
        dist_to_water = distance_transform_edt(~water_mask)
        dist_inv = np.nanmax(dist_to_water) - dist_to_water
        components['distance_to_water'] = utils.normalize_array(dist_inv)
    else:
        logging.warning("No river or waterbody geometries found. Skipping 'distance to water' component.")
        components['distance_to_water'] = np.zeros(dem.shape, dtype=float)

    # 5. Drainage Density (proxy)
    logging.info("Calculating drainage density component...")
    river_geoms = clipped_data['rivers'].geometry
    if not river_geoms.empty:
        river_mask = rasterize(
            [(g, 1) for g in river_geoms],
            out_shape=dem.shape,
            transform=profile['transform'],
            fill=0,
            dtype='uint8'
        )
        # Use a uniform filter as a proxy for density in a moving window
        window_size = 10 # 10x10 pixel window
        drainage_density = uniform_filter(river_mask.astype(float), size=window_size)
        components['drainage_density'] = utils.normalize_array(drainage_density)
    else:
        logging.warning("No river geometries found. Skipping 'drainage density' component.")
        components['drainage_density'] = np.zeros(dem.shape, dtype=float)
    
    # --- Combine Components ---
    logging.info("Combining vulnerability components...")
    vulnerability_raster = np.zeros_like(dem, dtype=float)
    for name, weight in tqdm(weights.items(), desc="Combining Vulnerability"):
        component = components[name]
        component[nodata_mask] = 0 # Ensure nodata areas don't contribute
        vulnerability_raster += component * weight
        
    vulnerability_raster[nodata_mask] = np.nan # Re-apply nodata mask
    
    # --- Apply Heuristics ---
    # 6. Reservoir Overflow Heuristic (if threat is high)
    if threat_score > params['reservoir_threat_threshold']:
        logging.info("High threat detected. Applying reservoir overflow heuristic...")
        reservoirs_gdf = clipped_data.get('reservoirs')
        if reservoirs_gdf is not None and not reservoirs_gdf.empty:
            # Create a mask of reservoir locations
            reservoir_mask = rasterize(
                [(g, 1) for g in reservoirs_gdf.geometry],
                out_shape=dem.shape, transform=profile['transform'], fill=0, dtype='uint8'
            ).astype(bool)
            
            # Find the "edge" of the reservoirs (potential spill points)
            # This is a simplified proxy for finding spillways.
            spill_points = reservoir_mask & ~binary_erosion(reservoir_mask)
            
            # Identify areas downstream by finding pixels near spill points with lower elevation
            spill_elevation = np.where(spill_points, dem, np.inf)
            min_spill_elevation = np.min(spill_elevation, axis=None, initial=np.inf)
            
            # Define downstream as areas lower than the lowest spill point elevation
            # A more complex model would use flow direction.
            downstream_mask = (dem < min_spill_elevation) & ~nodata_mask
            
            # Increase vulnerability in these downstream areas
            multiplier = params.get('reservoir_downstream_multiplier', 1.5)
            vulnerability_raster[downstream_mask] *= multiplier
            logging.info(f"Increased vulnerability for {np.sum(downstream_mask)} downstream pixels.")

    # Final normalization and clipping
    final_vulnerability = utils.normalize_array(vulnerability_raster)
    return np.clip(final_vulnerability, 0, 1)